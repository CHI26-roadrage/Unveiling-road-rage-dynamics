<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Unveiling Road Rage Dynamics</title>
  <style>
    :root {
      --maxw: 1200px;
      --fg: #333;
      --bg: #f9f9f9;
      --muted: #6b7280;
      --primary: #2563eb;
      --primary-20: rgba(37, 99, 235, 0.2);
      --grid: #e5e7eb;
      --card: #ffffff;
      --shadow: 0 4px 10px rgba(0,0,0,0.08);
      --radius: 12px;

      --phase-safe: rgba(16, 185, 129, 0.10); /* 浅绿色 */
      --phase-rage: rgba(239, 68, 68, 0.10);  /* 浅红色 */
    }

    * { box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
      margin: 0;
      padding: 20px;
      background-color: var(--bg);
      color: var(--fg);
    }

    h1 {
      text-align: center;
      max-width: var(--maxw);
      margin: 0 auto 28px;
      line-height: 1.35;
      font-size: clamp(1.4rem, 1rem + 2vw, 2rem);
    }

    .container {
      display: flex;
      justify-content: space-between;
      gap: 30px;
      max-width: var(--maxw);
      margin: 0 auto;
    }

    .image-box {
      flex: 1;
      text-align: center;
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
    }

    .image-box img {
      width: 100%;
      height: auto;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.06);
    }

    .image-box p {
      margin-top: 10px;
      font-weight: 600;
      font-size: 1.05em;
    }

    .abstract, .section, .dyn {
      max-width: var(--maxw);
      margin: 28px auto;
      padding: 18px 20px;
      line-height: 1.75;
      font-size: 1.05em;
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .abstract h2, .section h2, .dyn h2 {
      margin: 0 0 10px;
      font-size: 1.25em;
    }

    .muted {
      color: var(--muted);
      font-size: 0.95em;
      margin-top: 6px;
    }

    .fig-card {
      margin-top: 14px;
      border: 1px solid #eef2f7;
      border-radius: 10px;
      overflow: hidden;
      background: #fff;
    }
    .fig-head {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: #fafbff;
      border-bottom: 1px solid #eef2f7;
      color: #374151;
      font-size: 0.98rem;
    }
    .fig-dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: var(--primary);
      box-shadow: 0 0 0 4px var(--primary-20) inset;
    }
    .fig-body {
      padding: 10px;
    }
    .fig-body img {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 8px;
    }
    .fig-caption {
      margin-top: 8px;
      color: #4b5563;
      font-size: 0.95em;
    }

    /* chart */
    .chart-wrap {
      margin-top: 16px;
      width: 100%;
    }

    .chart-card {
      position: relative;
      width: 100%;
      background: #fff;
      border-radius: 10px;
      box-shadow: inset 0 1px 0 rgba(0,0,0,0.02);
      overflow: hidden;
      border: 1px solid #eef2f7;
    }

    canvas {
      width: 100%;
      height: 320px;
      display: block;
    }

    .legend {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border: 1px dashed #e5e7eb;
      border-radius: 8px;
      background: #fafbff;
      color: #374151;
      font-size: 0.95rem;
      margin-top: 8px;
    }
    .legend-color {
      width: 14px;
      height: 14px;
      background: var(--primary);
      border-radius: 3px;
      box-shadow: 0 0 0 3px var(--primary-20) inset;
    }

    .tip {
      position: absolute;
      pointer-events: none;
      background: #111827;
      color: #fff;
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 6px;
      transform: translate(-50%, -120%);
      white-space: nowrap;
      opacity: 0;
      transition: opacity .15s ease;
      z-index: 10;
    }
    .tip::after {
      content: "";
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: #111827;
    }

    @media (max-width: 900px) {
      .container {
        flex-direction: column;
      }
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 1.35rem;
      }
      .abstract, .section, .dyn {
        font-size: 1rem;
        padding: 16px;
      }
      canvas {
        height: 260px;
      }
    }
  </style>
</head>
<body>

  <!-- 标题 -->
  <h1>Unveiling Road Rage Dynamics: Recreating and Modeling Road Rage in Audiovisual and Simulating Environments Based on Real-World Footage</h1>

  <!-- 图片区域：左GIF右图 -->
  <div class="container">
    <div class="image-box">
      <img src="IMG_0974.GIF" alt="R³-Ftg Dataset">
      <p>R<sup>3</sup>-Ftg Dataset</p>
    </div>
    <div class="image-box">
      <img src="IMG_Scene.png" alt="Self Report / EEG Response">
      <p>Self Report / EEG Response</p>
    </div>
  </div>

  <!-- 摘要 -->
  <div class="abstract">
    <h2>Abstract</h2>
    <p>
      Road rage poses great risks to road safety. Digital interventions show promising potential in regulating rage-related maladaptive behaviors to mitigate such risks. This requires a clear understanding of road rage dynamics. Unlike prior work using artificial scenarios, we build the first-of-its-kind Real Road Rage Footage (R<sup>3</sup>-Ftg) dataset and recreate some of its most risky and anger-inducing scenes in both audiovisual and simulating environments. Then we recruit 60 participants to experience those scenes and record their rage in subjective and objective measures. We find: (1) Road rage has been successfully induced, and simulation provides more realistic experiences. (2) Slow-rise-fast-decay phenomena are observed in both stimuli, suggesting a spring-like process of road rage. (3) This process can be modeled using second-order damped oscillation distributions. To our knowledge, we are the first to model road rage dynamics in authentic scenarios recreated from real-world events, enabling a paradigm shift from learning-based to model-based digital solutions.
    </p>

    <!-- 摘要配图（JPG） -->
    <div class="fig-card" aria-label="Main figure">
      <div class="fig-head">
        <span class="fig-dot" aria-hidden="true"></span>
        <strong>Main Figure</strong>
        <span class="muted" style="margin-left:auto;">fig1.jpg</span>
      </div>
      <div class="fig-body">
        <img src="fig1.jpg" alt="Main figure illustration">
        <div class="fig-caption">Main figure illustrating the study overview.</div>
      </div>
    </div>
  </div>

  <!-- 新增说明区块（含 fig2） -->
  <div class="section">
    <h2>Simulation Reconstruction</h2>
    <p>
      Recreating road rage in the simulating environment using labels of physical/traffic conditions and interactions events from the R<sup>3</sup>-Ftg dataset. The experiments consists of driving through 3 routes: Route 1 (3 min) provided a neutral baseline with autonomous vehicles following traffic rules. At 3 min, it transitioned to Route 2 (5 min), featuring five ecologically valid road rage scenes reconstructed from top-3 footage. Route 3 (3 min) reinstated the neutral condition, mirroring Route 1’s behavior and compliance.
    </p>
    <div class="fig-card" aria-label="Simulation routes figure">
      <div class="fig-head">
        <span class="fig-dot" aria-hidden="true"></span>
        <strong>Figure 2</strong>
        <span class="muted" style="margin-left:auto;">fig2.JPG</span>
      </div>
      <div class="fig-body">
        <img src="fig2.JPG" alt="Recreated routes and conditions in simulation">
        <div class="fig-caption">Recreated neutral–rage–neutral sequence (Route 1 → Route 2 → Route 3).</div>
      </div>
    </div>
  </div>

  <!-- 动态曲线 -->
  <div class="dyn">
    <h2>Dynamics: Anger Rise and Dissipation</h2>
    <div class="muted">X-axis: Time (minutes, 1 → 11) • Y-axis: Anger value • 11 sampled points</div>

    <div class="chart-wrap">
      <div class="chart-card">
        <canvas id="rageChart"></canvas>
        <div id="tooltip" class="tip"></div>
      </div>
      <div class="legend"><span class="legend-color"></span> Rage dynamics (slow rise, fast decay)</div>
    </div>
  </div>

  <script>
    // Data: 11 points at minutes 1..11
    const data = [
      0.111, 0.111, 0.333333333, 1.222222222, 2.277777778,
      2.5, 2.555555556, 2.222222222, 0.111111111, 0.055555556, 0.055555556
    ];
    // Minutes labeling from 1 to 11
    const minutes = Array.from({length: 11}, (_, i) => i + 1);

    // Canvas setup with devicePixelRatio for crisp lines
    const canvas = document.getElementById('rageChart');
    const tip = document.getElementById('tooltip');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const cssWidth = canvas.clientWidth;
      const cssHeight = canvas.clientHeight;
      canvas.width = Math.floor(cssWidth * dpr);
      canvas.height = Math.floor(cssHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
      draw();
    }
    window.addEventListener('resize', resizeCanvas);

    // Chart state
    const state = {
      padding: { top: 24, right: 18, bottom: 40, left: 50 },
      t: 0,          // animation progress [0..1]
      hoverIdx: -1
    };

    // Easing: slow rise, fast decay
    // We'll modulate per-segment speed: earlier segments slower, later (decay) segments faster.
    // Create a per-segment speed profile based on slope (rise vs decay).
    function buildSegmentSpeeds(values) {
      const speeds = []; // higher speed = faster time progression on that segment
      for (let i = 0; i < values.length - 1; i++) {
        const dy = values[i + 1] - values[i];
        // Base speed
        let s = 1;
        if (dy >= 0) {
          // Rising: slow -> smaller speed
          s = 0.6; // slower progression
        } else {
          // Decay: fast -> larger speed
          s = 1.8;
        }
        // Slightly weight by magnitude
        s *= 0.8 + 0.2 * Math.min(3, Math.abs(dy) / Math.max(0.001, Math.max(...values)));
        speeds.push(s);
      }
      return speeds;
    }

    const segSpeeds = buildSegmentSpeeds(data);

    // Build a cumulative time map so that total normalized time = 1
    function buildTimeMap(speeds) {
      // Each of the N-1 segments gets an inverse of speed as duration weight (slower speed => larger duration)
      const weights = speeds.map(s => 1 / s);
      const sum = weights.reduce((a, b) => a + b, 0);
      const cum = [0];
      let acc = 0;
      for (let w of weights) {
        acc += w / sum;
        cum.push(acc);
      }
      cum[cum.length - 1] = 1; // ensure end at 1
      return cum; // length N (points)
    }

    const timeMap = buildTimeMap(segSpeeds);
    // For global easing (gentle in-out), apply an S-curve to t before mapping to segment
    function easeInOut(t) {
      return t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t + 2, 2)/2;
    }

    // Derived scales
    function getScales() {
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;
      const { left, right, top, bottom } = state.padding;
      const iw = W - left - right;
      const ih = H - top - bottom;

      // X: minutes 1..11 mapped to indices 0..10
      const xMin = 1, xMax = 11;
      const x = (m) => left + (m - xMin) / (xMax - xMin) * iw;

      // Y baseline at 0
      const yMin = 0;
      const yMax = Math.max(...data) * 1.1;
      const y = (v) => top + (1 - (v - yMin) / (yMax - yMin)) * ih;

      return { x, y, iw, ih, W, H, xMin, xMax, yMin, yMax };
    }

    // Ticks
    function niceTicks(min, max, count) {
      const span = max - min;
      if (span <= 0) return { ticks: [min] };
      const step0 = span / Math.max(1, count);
      const mag = Math.pow(10, Math.floor(Math.log10(step0)));
      const norm = step0 / mag;
      let step;
      if (norm < 1.5) step = 1 * mag;
      else if (norm < 3) step = 2 * mag;
      else if (norm < 7) step = 5 * mag;
      else step = 10 * mag;
      const niceMin = Math.ceil(min / step) * step;
      const niceMax = Math.floor(max / step) * step;
      const ticks = [];
      for (let v = niceMin; v <= niceMax + 1e-9; v += step) ticks.push(Number(v.toFixed(10)));
      return { ticks, step, niceMin, niceMax };
    }

    function drawBackgroundPhases(scales) {
      const { x } = scales;
      const { top, bottom, left, right } = state.padding;
      const H = canvas.clientHeight;

      // Phases: [1,3] safe, (3,8] rage, (8,11] safe
      ctx.save();
      // Safe 1–3
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--phase-safe').trim();
      ctx.fillRect(x(1), top, x(3) - x(1), H - top - bottom);
      // Rage 3–8
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--phase-rage').trim();
      ctx.fillRect(x(3), top, x(8) - x(3), H - top - bottom);
      // Safe 8–11
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--phase-safe').trim();
      ctx.fillRect(x(8), top, x(11) - x(8), H - top - bottom);
      ctx.restore();
    }

    function drawAxesGrid(scales) {
      const { x, y, W, H, xMin, xMax, yMin, yMax } = scales;
      const { left, right, top, bottom } = state.padding;

      ctx.clearRect(0, 0, W, H);

      // Background phases
      drawBackgroundPhases(scales);

      // Grid
      ctx.save();
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;

      const yt = niceTicks(yMin, yMax, 5).ticks;
      yt.forEach(tv => {
        const yy = y(tv);
        ctx.beginPath();
        ctx.moveTo(left, yy);
        ctx.lineTo(W - right, yy);
        ctx.stroke();
      });

      // Minute ticks: 1..11
      for (let m = 1; m <= 11; m++) {
        const xx = x(m);
        ctx.beginPath();
        ctx.moveTo(xx, top);
        ctx.lineTo(xx, H - bottom);
        ctx.stroke();
      }
      ctx.restore();

      // Axes
      ctx.save();
      ctx.strokeStyle = '#9ca3af';
      ctx.lineWidth = 1.2;
      // Y axis
      ctx.beginPath();
      ctx.moveTo(left, top);
      ctx.lineTo(left, H - bottom);
      ctx.stroke();
      // X axis
      ctx.beginPath();
      ctx.moveTo(left, H - bottom);
      ctx.lineTo(W - right, H - bottom);
      ctx.stroke();
      ctx.restore();

      // Labels
      ctx.save();
      ctx.fillStyle = '#374151';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';

      // Y labels
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      niceTicks(yMin, yMax, 5).ticks.forEach(tv => {
        const yy = y(tv);
        ctx.fillText(tv.toFixed(2), left - 6, yy);
      });

      // X labels: minutes 1..11
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      for (let m = 1; m <= 11; m++) {
        const xx = x(m);
        ctx.fillText(String(m), xx, H - bottom + 6);
      }

      // Axis titles
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText('Time (minutes)', (left + W - right) / 2, H - 4);

      ctx.save();
      ctx.translate(14, (top + H - bottom) / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText('Anger value', 0, 0);
      ctx.restore();
      ctx.restore();

      // Phase captions
      ctx.save();
      ctx.fillStyle = '#065f46';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      const yCap = top + 8;
      ctx.textAlign = 'left';
      ctx.fillText('Neutral (Route 1)', x(1) + 6, yCap);
      ctx.fillStyle = '#7f1d1d';
      ctx.fillText('Rage scenes (Route 2)', x(3) + 6, yCap);
      ctx.fillStyle = '#065f46';
      ctx.fillText('Neutral (Route 3)', x(8) + 6, yCap);
      ctx.restore();
    }

    // Smooth line path with Catmull-Rom to Bezier
    function pathSmooth(points) {
      if (points.length < 2) return;
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i - 1] || points[i];
        const p1 = points[i];
        const p2 = points[i + 1];
        const p3 = points[i + 2] || p2;
        const t = 0.5;
        const cp1x = p1.x + (p2.x - p0.x) * t / 6;
        const cp1y = p1.y + (p2.y - p0.y) * t / 6;
        const cp2x = p2.x - (p3.x - p1.x) * t / 6;
        const cp2y = p2.y - (p3.y - p1.y) * t / 6;
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
      }
    }

    function drawSeries(scales) {
      const { x, y } = scales;

      // Map eased global t to segment index using timeMap
      const te = easeInOut(state.t);
      // Find segment i such that timeMap[i] <= te <= timeMap[i+1]
      let i = 0;
      while (i < timeMap.length - 1 && te > timeMap[i + 1]) i++;
      const t0 = timeMap[i];
      const t1 = timeMap[i + 1] ?? 1;
      const local = t1 > t0 ? (te - t0) / (t1 - t0) : 1;

      // Build points up to i, and interpolate within current segment
      const pts = [];
      for (let k = 0; k <= i; k++) {
        pts.push({ x: x(minutes[k]), y: y(data[k]) });
      }
      if (i < data.length - 1) {
        const v = data[i] + (data[i + 1] - data[i]) * local;
        const xm = minutes[i] + (minutes[i + 1] - minutes[i]) * local;
        pts.push({ x: x(xm), y: y(v) });
      }

      // Area fill
      ctx.save();
      ctx.fillStyle = 'rgba(37,99,235,0.08)';
      if (pts.length > 1) {
        pathSmooth(pts);
        ctx.lineTo(pts[pts.length - 1].x, y(0));
        ctx.lineTo(pts[0].x, y(0));
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();

      // Line
      ctx.save();
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary').trim() || '#2563eb';
      ctx.lineWidth = 2;
      if (pts.length > 1) {
        pathSmooth(pts);
        ctx.stroke();
      }
      ctx.restore();

      // Points
      ctx.save();
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = 'rgba(37,99,235,0.9)';
      ctx.lineWidth = 2;
      const drawPoint = (px, py, r=3.5) => {
        ctx.beginPath();
        ctx.arc(px, py, r, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      };
      for (let k = 0; k < Math.min(pts.length, data.length); k++) {
        drawPoint(pts[k].x, pts[k].y, 3.5);
      }
      ctx.restore();
    }

    function drawHover(scales) {
      if (state.hoverIdx < 0) return;
      const { x, y } = scales;
      const idx = state.hoverIdx;
      const px = x(minutes[idx]);
      const py = y(data[idx]);

      // Vertical guide
      ctx.save();
      ctx.strokeStyle = 'rgba(17,24,39,0.25)';
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(px, state.padding.top);
      ctx.lineTo(px, canvas.clientHeight - state.padding.bottom);
      ctx.stroke();
      ctx.restore();

      // Emphasize point
      ctx.save();
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(px, py, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function draw() {
      const scales = getScales();
      drawAxesGrid(scales);
      drawSeries(scales);
      drawHover(scales);
    }

    // Animation loop: auto-play on load
    let raf = null;
    function animate() {
      state.t = Math.min(1, state.t + 0.012); // base increment (frame-rate independent not strictly needed here)
      draw();
      if (state.t < 1) {
        raf = requestAnimationFrame(animate);
      }
    }

    // Hover tooltip
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const xCss = e.clientX - rect.left;
      const scales = getScales();
      const step = (scales.W - state.padding.left - state.padding.right) / (minutes.length - 1);
      const idx = Math.round((xCss - state.padding.left) / step);
      if (idx >= 0 && idx < data.length) {
        state.hoverIdx = idx;
        tip.style.opacity = 1;
        tip.style.left = `${Math.max(state.padding.left, Math.min(xCss, canvas.clientWidth - state.padding.right))}px`;
        tip.style.top = `${Math.max(10, Math.min(scales.y(data[idx]), canvas.clientHeight - 30))}px`;
        tip.textContent = `t=${minutes[idx]} min • anger=${data[idx].toFixed(3)}`;
      } else {
        state.hoverIdx = -1;
        tip.style.opacity = 0;
      }
      draw();
    });

    canvas.addEventListener('mouseleave', () => {
      state.hoverIdx = -1;
      tip.style.opacity = 0;
      draw();
    });

    // Initial render + autoplay
    resizeCanvas();
    // Small delay to ensure layout is stable before drawing/animating
    requestAnimationFrame(() => {
      state.t = 0;
      animate();
    });
  </script>
</body>
</html>